////  CreateFlashcardView.swift//  Group10FinalProject////  Created by user264785 on 11/22/24.//import SwiftUIimport UIKitimport Visionimport Firebasestruct CreateFlashcardView: View {    @State private var selectedImage: UIImage? = nil    @State private var flashcards: [Flashcard] = [] // Flashcard list    @State private var flashcardStatusMessage: String = "" // Status message    @State private var isLoading: Bool = false // Loading state    @State private var showImagePicker = false    @State private var sourceType: UIImagePickerController.SourceType = .photoLibrary    @State private var showSourceSelection = false    @State private var showFlashcardsView = false // State for navigation to FlashcardsTableView    @Environment(\.presentationMode) var presentationMode            var body: some View {        NavigationView {            VStack(spacing: 20) {                Text("Create Flashcard")                    .font(.largeTitle)                    .bold()                    .padding(.top, 20)                                HStack(spacing: 30) {                    // Image selection button                    VStack {                        Button(action: {                            showSourceSelection = true                        }) {                            Image(systemName: "photo")                                .resizable()                                .frame(width: 60, height: 60)                                .foregroundColor(.blue)                        }                        Text("Image")                            .font(.headline)                    }                                        // GPT generation button                    VStack {                        Button(action: {                            if let image = selectedImage {                                generateFlashcards(from: image)                            } else {                                flashcardStatusMessage = "Please select an image first."                            }                        }) {                            Image(systemName: "bubble.left.and.bubble.right")                                .resizable()                                .frame(width: 60, height: 60)                                .foregroundColor(.green)                        }                        Text("GPT")                            .font(.headline)                    }                                        // View flashcards button                    VStack {                        NavigationLink(                            destination: FlashcardsTableView(flashcards: flashcards),                            isActive: $showFlashcardsView                        ) {                            EmptyView() // Hidden NavigationLink                        }                        Button(action: {                            loadFlashcardsFromFirebase { loadedFlashcards in                                self.flashcards = loadedFlashcards                                if !flashcards.isEmpty {                                    showFlashcardsView = true // Navigate to FlashcardsTableView                                } else {                                    flashcardStatusMessage = "No flashcards available yet."                                }                            }                        }) {                            Image(systemName: "rectangle.stack.fill")                                .resizable()                                .frame(width: 60, height: 60)                                .foregroundColor(.orange)                        }                        Text("Flashcards")                            .font(.headline)                    }                }                                Spacer()                                // Display loading or image preview                if isLoading {                    ProgressView("Generating flashcards...")                        .padding()                } else {                    if let image = selectedImage {                        Image(uiImage: image)                            .resizable()                            .scaledToFit()                            .frame(height: 200)                            .padding()                    } else {                        Text("No image selected.")                            .foregroundColor(.gray)                    }                    Text(flashcardStatusMessage)                        .foregroundColor(flashcardStatusMessage == "Success!" ? .green : .red)                        .font(.headline)                }                                Spacer()                                // Back button                Button(action: {                    presentationMode.wrappedValue.dismiss()                }) {                    Text("Back")                        .frame(maxWidth: .infinity, minHeight: 50)                        .background(Color.red.opacity(0.8))                        .foregroundColor(.white)                        .cornerRadius(10)                        .padding(.horizontal, 20)                }            }            .padding()            .navigationBarHidden(true)            .sheet(isPresented: $showImagePicker) {                ImagePicker(sourceType: sourceType, selectedImage: $selectedImage)            }            .actionSheet(isPresented: $showSourceSelection) {                ActionSheet(                    title: Text("Select Image Source"),                    message: Text("Choose the source to pick an image"),                    buttons: [                        .default(Text("Camera")) {                            sourceType = .camera                            showImagePicker = true                        },                        .default(Text("Photo Library")) {                            sourceType = .photoLibrary                            showImagePicker = true                        },                        .cancel()                    ]                )            }        }    }      private func generateFlashcards(from image: UIImage) {       isLoading = true       guard let cgImage = image.cgImage else {           flashcardStatusMessage = "Failed to process image."           isLoading = false           return       }              let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])       let request = VNRecognizeTextRequest { request, error in           guard let observations = request.results as? [VNRecognizedTextObservation], error == nil else {               DispatchQueue.main.async {                   self.flashcardStatusMessage = "Text recognition failed."                   self.isLoading = false               }               return           }                      let paragraph = observations.compactMap { $0.topCandidates(1).first?.string }.joined(separator: " ")           DispatchQueue.main.async {               self.generateFlashcardsFromGPT(paragraph: paragraph)           }       }              DispatchQueue.global(qos: .userInitiated).async {           do {               try requestHandler.perform([request])           } catch {               DispatchQueue.main.async {                   self.flashcardStatusMessage = "Error recognizing text."                   self.isLoading = false               }           }       }   }      private func generateFlashcardsFromGPT(paragraph: String) {       Task {           let prompt = """           Analyze the following text. Extract all technical or professional terms and provide their accurate and concise explanations.           Format the response as:           Term: <term>           Explanation: <explanation>                      Text: \(paragraph)           """                      let apiKey = "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"           let url = URL(string: "https://api.openai.com/v1/chat/completions")!                      var request = URLRequest(url: url)           request.httpMethod = "POST"           request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")           request.addValue("application/json", forHTTPHeaderField: "Content-Type")                      let requestBody: [String: Any] = [               "model": "gpt-3.5-turbo",               "messages": [["role": "user", "content": prompt]],               "max_tokens": 1000,               "temperature": 0.7           ]                      request.httpBody = try? JSONSerialization.data(withJSONObject: requestBody)                      do {               let (data, _) = try await URLSession.shared.data(for: request)               if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],                  let choices = json["choices"] as? [[String: Any]],                  let content = choices.first?["message"] as? [String: Any],                  let text = content["content"] as? String {                   self.flashcards = parseFlashcards(from: text)                   self.flashcardStatusMessage = self.flashcards.isEmpty ? "Failed to generate flashcards." : "Success!"                   self.flashcards = parseFlashcards(from: text)                   saveFlashcardsToFirebase()               } else {                   self.flashcardStatusMessage = "Failed to parse GPT response."               }           } catch {               self.flashcardStatusMessage = "Error fetching flashcards: \(error.localizedDescription)"           }           self.isLoading = false       }   }   private func extractTextFromImage(_ image: UIImage) -> String {       guard let cgImage = image.cgImage else {           return ""       }       let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])       let request = VNRecognizeTextRequest()       request.recognitionLevel = .accurate       request.usesLanguageCorrection = true       var extractedText = ""       do {           try requestHandler.perform([request])           if let observations = request.results {               extractedText = observations.compactMap { $0.topCandidates(1).first?.string }.joined(separator: " ")           }       } catch {           print("Text extraction failed: \(error.localizedDescription)")       }       return extractedText   }      private func parseFlashcards(from response: String) -> [Flashcard] {       var flashcards: [Flashcard] = []              let lines = response.split(separator: "\n")       var currentTerm: String? = nil              for line in lines {           if line.starts(with: "Term:") {               currentTerm = line.replacingOccurrences(of: "Term: ", with: "").trimmingCharacters(in: .whitespaces)           } else if line.starts(with: "Explanation:") {               let explanation = line.replacingOccurrences(of: "Explanation: ", with: "").trimmingCharacters(in: .whitespaces)               if let term = currentTerm {                   flashcards.append(Flashcard(term: term, explanation: explanation))                   currentTerm = nil               }           }       }              return flashcards   }}struct Flashcard {   let term: String   let explanation: String}import FirebaseFirestoreimport FirebaseCoreimport FirebaseAuthextension CreateFlashcardView {    private func saveFlashcardsToFirebase() {        let db = Firestore.firestore()        guard !flashcards.isEmpty else { return }                let userID = Auth.auth().currentUser?.uid ?? "guest"        let collectionRef = db.collection("users").document(userID).collection("flashcards")                for flashcard in flashcards {            let data: [String: Any] = [                "term": flashcard.term,                "explanation": flashcard.explanation,                "timestamp": Timestamp()            ]            collectionRef.addDocument(data: data) { error in                if let error = error {                    print("Error saving flashcard: \(error.localizedDescription)")                } else {                    print("Flashcard saved: \(flashcard.term)")                }            }        }    }    private func saveFlashcardsLocally() {        guard !flashcards.isEmpty else {            flashcardStatusMessage = "No flashcards to save."            return        }        // Map to FlashcardModel for local storage        let individualFlashcards = flashcards.map { FlashcardModel(id: UUID().uuidString, question: $0.term, answer: $0.explanation) }        print("Saving the following flashcards locally: \(individualFlashcards)")        // Save to SessionManager        SessionManager.shared.saveIndividualFlashcards(individualFlashcards)        flashcardStatusMessage = "Flashcards saved locally!"        print("Saved individual flashcards locally: \(individualFlashcards.count)")    }    private func loadFlashcardsFromFirebase(completion: @escaping ([Flashcard]) -> Void) {        let db = Firestore.firestore()        let userID = Auth.auth().currentUser?.uid ?? "guest"        let collectionRef = db.collection("users").document(userID).collection("flashcards")                collectionRef.order(by: "timestamp", descending: false).getDocuments { snapshot, error in            if let error = error {                print("Error loading flashcards: \(error.localizedDescription)")                completion([])            } else {                var loadedFlashcards: [Flashcard] = []                if let documents = snapshot?.documents {                    for document in documents {                        let data = document.data()                        if let term = data["term"] as? String, let explanation = data["explanation"] as? String {                            loadedFlashcards.append(Flashcard(term: term, explanation: explanation))                        }                    }                }                completion(loadedFlashcards)            }        }    }}